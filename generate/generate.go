package generate

import (
	"fmt"
	"html/template"
	"os"
	"reflect"
	"strings"
)

func Adaptor(handler interface{}, filepath, pkg, target string) error {
	typ := reflect.TypeOf(handler)
	info, err := CollectInfo(typ)
	if err != nil {
		return err
	}
	file, err := os.Create(filepath)
	if err != nil {
		return err
	}

	tmpl, err := template.New("adaptor").
		Funcs(template.FuncMap{
			"typename": func(arg interface{}) string {
				str := fmt.Sprintf("%s", arg)
				return strings.TrimPrefix(str, pkg+".")
			},
		}).
		Option("missingkey=error").
		Parse(adaptorTemplate)

	if err != nil {
		return err
	}

	return tmpl.Execute(file, map[string]interface{}{
		"info":       info,
		"package":    pkg,
		"target":     target,
		"lastOutput": len(info.Outputs) - 1,
	})
}

const adaptorTemplate = `
package {{.package}}

//code generated by 'go generate', do not edit

import (
	"github.com/jargv/midus"
	"net/http"
	"reflect"
	"encoding/json"
	"fmt"
	"log"
)

//packages "used" even if not used below
var _ json.Delim
var _ log.Logger
var _ fmt.Formatter

func init(){
	typ := reflect.TypeOf({{.target}})
	midus.RegisterAdaptor(typ, {{.target}}_adaptor)
}

func responseError(res http.ResponseWriter, err error) {
	if err, ok := err.(midus.HTTPError); ok {
		http.Error(res, err.Error(), err.ResponseCode())
	} else {
		http.Error(res, "", http.StatusInternalServerError)
	}
}

func {{.target}}_adaptor(handler interface{}) http.HandlerFunc {
	callback := handler.(func(
		{{range $_, $arg := .info.Inputs}}
			{{typename $arg}},
		{{end}}
	)(
		{{range $_, $output := .info.Outputs}}
			{{typename $output}},
		{{end}}
	))

	return http.HandlerFunc(func(res http.ResponseWriter, req *http.Request){
		{{$info := .info}}
		{{range $i, $arg := $info.Inputs}}
			var arg{{$i}} {{typename $arg}}
			{{if eq $i $info.RequestBodyIndex}}
				{
					dec := json.NewDecoder(req.Body)

					if err := dec.Decode(&arg{{$i}}); err != nil {
						msg := fmt.Sprintf("error decoding json: %s", err.Error())
						http.Error(res, msg, http.StatusBadRequest)
						return
					}
				}
			{{else}}
				if err := arg{{$i}}.FromRequest(req); err != nil {
					responseError(res, err)
					return
				}
			{{end}}
		{{end}}

		{{$lastOutput := .lastOutput}}
		{{range $i, $_ := .info.Outputs}}
			result{{$i}} {{if eq $i $lastOutput}} := {{else}} , {{end}}
		{{end}}

		callback(
			{{range $i, $_ := .info.Inputs}}
			arg{{$i}},
			{{end}}
		)

		{{$lastIsError := .info.LastIsError}}
		{{if $lastIsError}}
			if result{{$lastOutput}} != nil {
				log.Println("unhandled error:", result{{$lastOutput}})
				responseError(res, result{{$lastOutput}}.(error))
				return
			}
		{{end}}

		{{range $i, $_ := .info.Outputs}}
			{{if or (ne $i $lastOutput) (not $lastIsError)}}
				{{if eq $i $info.ResponseBodyIndex}}
					{
						enc := json.NewEncoder(res)
						err := enc.Encode(result{{$i}})
						if err != nil {
							log.Printf("json encoding error: %s", err.Error())
							http.Error(res, "", http.StatusInternalServerError)
							return
						}
					}
				{{else}}
					if err := result{{$i}}.ToResponse(res); err != nil {
						responseError(res, err)
						return
					}
				{{end}}
			{{end}}
		{{end}}
	})
}
`
