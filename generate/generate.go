package generate

import (
	"fmt"
	"html/template"
	"os"
	"reflect"
	"strings"
)

func Adaptor(handler interface{}, filepath, pkg string) error {
	typ := reflect.TypeOf(handler)
	info, err := CollectInfo(typ)
	if err != nil {
		return err
	}
	file, err := os.Create(filepath)
	if err != nil {
		return err
	}

	tmpl, err := template.New("adaptor").
		Funcs(template.FuncMap{
			"typename": func(arg interface{}) string {
				typename := fmt.Sprintf("%s", arg)
				return strings.Replace(typename, pkg+".", "", 1)
			},
			"typenameElem": func(arg interface{}) string {
				typename := fmt.Sprintf("%s", arg)
				return strings.Replace(typename, "*"+pkg+".", "", 1)
			},
			"ConvertBody": func() ConversionType {
				return ConvertBody
			},
			"ConvertError": func() ConversionType {
				return ConvertError
			},
			"ConvertInterface": func() ConversionType {
				return ConvertInterface
			},
			"ConvertStringQueryParam": func() ConversionType {
				return ConvertStringQueryParam
			},
			"ConvertIntQueryParam": func() ConversionType {
				return ConvertIntQueryParam
			},
		}).
		Option("missingkey=error").
		Parse(adaptorTemplate)

	if err != nil {
		return err
	}

	return tmpl.Execute(file, map[string]interface{}{
		"info":       info,
		"package":    pkg,
		"lastOutput": len(info.Outputs) - 1,
	})
}

const adaptorTemplate = `
package {{.package}}

//code generated by 'go generate', do not edit

import (
	"github.com/jargv/plumbus"
	"net/http"
	"reflect"
	"encoding/json"
	"strconv"
	"fmt"
	"log"
)

// avoid unused import errors
var _ json.Delim
var _ log.Logger
var _ fmt.Formatter
var _ strconv.NumError

func init(){
	var dummy func(
		{{range $_, $input := .info.Inputs}}
			{{typename $input.Type}},
		{{end}}
	)(
		{{range $_, $output := .info.Outputs}}
			{{typename $output.Type}},
		{{end}}
	)

	typ := reflect.TypeOf(dummy)
	plumbus.RegisterAdaptor(typ, func(handler interface{}) http.HandlerFunc {
		callback := handler.(func(
			{{range $_, $input := .info.Inputs}}
				{{typename $input.Type}},
			{{end}}
		)(
			{{range $_, $output := .info.Outputs}}
				{{typename $output.Type}},
			{{end}}
		))

		return http.HandlerFunc(func(res http.ResponseWriter, req *http.Request){
			{{if .info.UsesQueryParams}}
				queryParams := req.URL.Query()
			{{end}}
			{{$info := .info}}
			{{range $i, $arg := $info.Inputs}}
				var arg{{$i}} {{typename $arg.Type -}}
				{{if eq $arg.ConversionType ConvertBody}}
					if err := json.NewDecoder(req.Body).Decode(&arg{{$i}}); err != nil {
						msg := fmt.Sprintf("{\"error\": \"decoding json: %s\"}", err.Error())
						http.Error(res, msg, http.StatusBadRequest)
						return
					}
				{{else if eq $arg.ConversionType ConvertInterface}}
					{{if $arg.IsPointer}}
						arg{{$i}} = new({{typenameElem $arg.Type}})
					{{end}}
					if err := arg{{$i}}.FromRequest(req); err != nil {
						plumbus.HandleResponseError(res, req, err)
						return
					}
				{{else if eq $arg.ConversionType ConvertStringQueryParam}}
					arg{{$i}} = {{typename $arg.Type}}(queryParams.Get("{{$arg.Name}}"))
				{{else if eq $arg.ConversionType ConvertIntQueryParam}}
					queryStr := queryParams.Get("{{$arg.Name}}")
					queryInt, err := strconv.Atoi(queryStr)
					if err != nil {
						plumbus.HandleResponseError(
							res, req,
							plumbus.Errorf(
								http.StatusBadRequest,
								"query param '{{$arg.Name}}' expected to be integer value",
							),
						)
						return
					}
					arg{{$i}} = {{typename $arg.Type}}(queryInt)
				{{end}}
			{{end}}

			{{$lastOutput := .lastOutput}}
			{{range $i, $_ := .info.Outputs}}
				result{{$i}} {{if eq $i $lastOutput}} := {{else}} , {{end}}
			{{end}}

			callback(
				{{range $i, $_ := .info.Inputs}}
					arg{{$i}},
				{{end}}
			)

			{{$lastIsError := .info.LastIsError}}
			{{if $lastIsError}}
				if result{{$lastOutput}} != nil {
					plumbus.HandleResponseError(res, req, result{{$lastOutput}}.(error))
					return
				}
			{{end}}

			{{range $i, $_ := .info.Outputs}}
				{{if or (ne $i $lastOutput) (not $lastIsError)}}
					{{if eq $i $info.ResponseBodyIndex}}
						{
							if err := json.NewEncoder(res).Encode(result{{$i}}); err != nil {
								plumbus.HandleResponseError(res, req, err)
								return
							}
						}
					{{else}}
						if err := result{{$i}}.ToResponse(res); err != nil {
							plumbus.HandleResponseError(res, req, err)
							return
						}
					{{end}}
				{{end}}
			{{end}}
		})
	})
}
`
